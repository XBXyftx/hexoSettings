---
title: 浅谈鸿蒙状态管理V1——>V2
date: 2025-02-04 01:02:36
tags:
  - 鸿蒙
  - 技术向
  - V2
cover: https://raw.githubusercontent.com/XBXyftx/hexoImgs3/main/20250204011404.png
post_copyright:
copyright_author: XBXyftx
copyright_author_href: https://github.com/XBXyftx
copyright_url: https://XBXyftx.github.io
copyright_info: 此文章版权归XBXyftx所有，如有转载，请註明来自原作者
---

## 前言

在鸿蒙开发中，状态管理是一个非常重要的概念。它涉及到如何在应用程序中**存储和管理数据**，以便在不同的组件、Ability之间共享和访问。
状态管理的目标是确保应用程序的**数据一致性**和**可维护性**。它还可以帮助开发者更好地理解应用程序的**数据流**和**数据依赖关系**，从而更好地设计和实现应用程序。

截止到目前，鸿蒙开发中的状态管理分为两个版本**V1和V2**。

V1作为最初的一代状态管理框架，其功能已经满足了绝大多数的应用开发需求，但仍有许多不足。
V2作为新一代的状态管理框架，其功能更加完善，能够更好地满足应用开发的需求。

![1](V1/1.png)

针对于V1和V2的区别，官方文档给出了十分详尽的解释。我也不再详细的赘述，直接给出官方文档的链接。
[V1——>V2迁移指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-v1-v2-migration-V5)
[V2装饰器指南](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-v2-decorators-V5)
[V2其他状态管理](https://developer.huawei.com/consumer/cn/doc/harmonyos-guides-V5/arkts-new-other-state-mgmt-V5)

接下来我会用我的实际经验来解释一些文档中写的有些晦涩的内容。

## `@State`和`@Loacl`、`@Param@Once`

### `@State`的缺陷与V2的解决方案

`@State`无疑是V1中最为常用的装饰器，它的作用是将一个变量声明为状态变量，当状态变量发生变化时，会自动更新视图。是想完成各种UI变化的**基石**

而`@Local`则是为了解决`@State`在外部初始化时无法准确表达组件内部状态不能被外面修改的语义的问题。
这个问题官方的描述有些抽象，我举个例子：

假设有一个计数器组件，内部有一个状态 count 表示当前的计数值。如果外部代码可以直接修改 count，可能会导致计数器的逻辑混乱。正确的做法应该是通过组件提供的接口（例如方法或事件）来间接修改状态，而不是直接访问和修改 count。

```ArkTS
@Entry
@Component
struct LocalState {
  @State countChange:number = 5
  aboutToAppear(): void {
    setInterval(()=>{
      this.countChange--
    },500)
  }
  build() {
    Column() {
      count({count:this.countChange})
    }
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width('100%')
  }
}
@Component
struct count{
  @State count: number = 0;
  aboutToAppear(): void {
    setInterval(()=>{
      this.count++
    },1000)
  }
  build() {
    Text(this.count.toString())
      .fontSize(50)
      .fontWeight(FontWeight.Bold)
  }
}
```

![2](V2/2.png)

这段代码中我们设置了计数器组件`count`的初始值为0，然后在`aboutToAppear`方法中使用`setInterval`方法每隔一秒钟将计数器的值加1。
但是，这段代码中存在一个问题，就是外部代码可以修改计数器的初始值。

`count({count:this.countChange})`这行代码将计时器的初始值设置为了5，但很显然这个组件的设计初衷是不想让内部数据被外部修改的。
V1版本的状态管理虽然可以通过其他方式来实现这个简单的初始化功能，但这并不利于组件功能的封装。
因此，V2版本的状态管理引入了`@Local`装饰器，它可以将一个变量声明为本地状态变量，只能在组件内部访问和修改。这样可以避免外部代码修改组件内部状态，从而提高组件的封装性和可维护性。

```ArkTS
@Entry
@ComponentV2
struct LocalState {
  @Local countChange:number = 5
  aboutToAppear(): void {
    setInterval(()=>{
      this.countChange--
    },500)
  }
  build() {
    Column() {
      count({count:this.countChange})
    }
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width('100%')
  }
}
@ComponentV2
struct count{
  @Local count: number = 0;
  aboutToAppear(): void {
    setInterval(()=>{
      this.count++
    },1000)
  }
  build() {
    Text(this.count.toString())
      .fontSize(50)
      .fontWeight(FontWeight.Bold)
  }
}
```

![3](V2/3.png)

由报错信息我们可以清晰的看到`'count' cannot be initialized here`，count不能在这里初始化。
这样就实现了我们的需求。

### `@Param`和`@Once`

上文说到`@State`的缺陷在于无法规范是否可以外部初始化的问题。`@Local`可以有效地阻隔外部初始化，来保障该状态变量仅为本组件内部使用。
但我们也确实会存在外部初始化的需求。
V2版本的状态管理引入了`@Param`和`@Once`装饰器。

#### `@Param`

`@Param`与`@Prop`的功能类似，都是定义一个状态变量从外部传入。

**区别：**

1. `@Prop`是单向绑定，只有父组件能影响子组件，子组件的**修改**无法影响父组件。
2. `@Param`也是单向绑定，**但是**在子组件内部无法对状态变量进行修改，只能读取！！！是`readonly`的。
3. 对于复杂类型如类对象，`@Param`会接受数据源的**引用(类似于地址值)**。在组件内可以修改类对象中的属性，该修改**会同步到数据源**。
4. 由第三条衍生出的一点就是，如果如果传递的是**复杂对象**且需要严格的**单向**数据绑定，应当对对象进行**深拷贝**，防止子组件修改父组件的数据。

针对于简单类型的前两点不同可以通过下面的例子来理解：

```ArkTS
@Entry
@ComponentV2
struct LocalState {
  @Local countChange: number = 5

  aboutToAppear(): void {
    setInterval(() => {
      this.countChange++
    }, 5000)
  }

  build() {
    Column() {
      Text(this.countChange.toString())
        .fontSize(50)
        .fontWeight(FontWeight.Bold)
      count({ count: this.countChange })
    }
    .justifyContent(FlexAlign.Center)
    .height('100%')
    .width('100%')
  }
}

@Component
struct count {
  @Prop count: number = 0;
  aboutToAppear(): void {
    setInterval(() => {
      this.count++
    }, 1000)
  }

  build() {
    Text(this.count.toString())
      .fontSize(50)
      .fontWeight(FontWeight.Bold)
  }
}
```

<video width="90%" controls>
  <source src="4.mp4" type="video/mp4">
  您的浏览器不支持视频标签。
</video>
